vim.cmd('highlight clear')
vim.g.colors_name = 'paragon'

-- Palette
local accent0, accent1, red, yellow, green, blue
local fg0, fg1, fg2
local bg_float, bg_norm, bg0, bg1, bg2, bg_active, bg_inactive

if vim.o.background == 'dark' then
  accent0 = '#ababed'
  accent1 = '#ebccab'
  red = '#e58787'
  yellow = '#faeb96'
  green = '#69c5a7'
  blue = '#3434ba'
  fg0 = '#e4e4e4'
  fg1 = '#c6c6c6'
  fg2 = '#949494'
  bg_float = '#080808'
  bg_norm = '#121212'
  bg0 = '#1c1c1c'
  bg1 = '#262626'
  bg2 = '#303030'
  bg_active = '#3a3a3a'
  bg_inactive = bg1
else
  accent0 = '#2424b0'
  accent1 = '#90571d'
  red = '#8d2020'
  yellow = '#7a6400'
  green = '#00523d'
  fg0 = '#121212'
  fg1 = '#303030'
  fg2 = '#626262'
  bg_float = '#eeeeee'
  bg_norm = '#e4e4e4'
  bg0 = '#dadada'
  bg1 = '#d0d0d0'
  bg2 = '#c6c6c6'
  bg_active = bg1
  bg_inactive = '#bcbcbc'
end

local accent_sel = accent1
local accent_unsel = accent0

-- Highlight definition function using nvim_set_hl
local function h(group, opts)
  vim.api.nvim_set_hl(0, group, opts)
end

-- Editor highlights
h('ColorColumn', { bg = bg1 })
h('Conceal', { link = 'Ignore' })
h('CurSearch', { link = 'IncSearch' })
h('Cursor', { fg = 'bg', bg = 'fg' })
h('lCursor', { link = 'Cursor' })
h('CursorIM', { link = 'Cursor' })
h('CursorColumn', { link = 'CursorLine' })
h('CursorLine', { bg = bg0 })
h('Directory', { fg = accent0 })
h('DiffAdd', { fg = bg0, bg = green })
h('DiffChange', { bg = bg2 })
h('DiffDelete', { fg = bg0, bg = red })
h('DiffText', { fg = bg0, bg = yellow })
h('DiffTextAdd', { link = 'DiffText' })
h('EndOfBuffer', { fg = bg_norm })
h('TermCursor', { reverse = true })
h('ErrorMsg', { fg = red })
h('VertSplit', { fg = bg0 })
h('WinSeparator', { link = 'VertSplit' })
h('Folded', { link = 'NonText' })
h('FoldColumn', { fg = fg2 })
h('SignColumn', { fg = accent0 })
h('IncSearch', { fg = bg0, bg = accent_sel })
h('Substitute', { link = 'Search' })
h('LineNr', { fg = fg2 })
h('LineNrAbove', { link = 'LineNr' })
h('LineNrBelow', { link = 'LineNr' })
h('CursorLineNr', { fg = fg0, bg = bg0 })
h('CursorLineFold', { link = 'FoldColumn' })
h('CursorLineSign', { link = 'SignColumn' })
h('MatchParen', { fg = accent_sel, bg = bg_float, bold = true })
h('MessageWindow', { link = 'WarningMsg' })
h('ModeMsg', { link = 'Normal' })
h('MsgArea', {})
h('MsgSeparator', { link = 'StatusLine' })
h('MoreMsg', { fg = accent0 })
h('NonText', { fg = fg2, bold = true })
h('Normal', { fg = fg0, bg = bg_norm })
h('NormalFloat', { fg = fg0, bg = bg_float })
h('FloatBorder', { fg = fg1, bg = bg_float })
h('FloatTitle', { link = 'NormalFloat' })
h('FloatFooter', { link = 'FloatTitle' })
h('NormalNC', {})
h('Pmenu', { fg = fg0, bg = bg2 })
h('PmenuSel', { link = 'CurSearch' })
h('PmenuKind', { link = 'Pmenu' })
h('PmenuKindSel', { link = 'PmenuSel' })
h('PmenuExtra', { link = 'Pmenu' })
h('PmenuExtraSel', { link = 'PmenuSel' })
h('PmenuSbar', { link = 'Pmenu' })
h('PmenuThumb', { bg = fg2 })
h('PmenuMatch', { bold = true })
h('PmenuMatchSel', { link = 'PmenuMatch' })
h('ComplMatchIns', {})
h('PopupNotification', { link = 'WarningMsg' })
h('PopupSelected', { link = 'PmenuSel' })
h('Question', { fg = accent1 })
h('QuickFixLine', { bg = bg2 })
h('Search', { fg = bg0, bg = accent_unsel })
h('SnippetTabstop', { link = 'Visual' })
h('SpecialKey', { fg = fg1, bold = true })
h('SpellBad', { undercurl = true, sp = red })
h('SpellCap', { undercurl = true, sp = yellow })
h('SpellLocal', { undercurl = true, sp = fg0 })
h('SpellRare', { undercurl = true, sp = green })
h('StatusLine', { fg = fg1, bg = bg_active })
h('StatusLineNC', { fg = fg1, bg = bg_inactive })
h('StatusLineTerm', { link = 'StatusLine' })
h('StatusLineTermNC', { link = 'StatusLineNC' })
h('TabLine', { link = 'StatusLineNC' })
h('TabLineFill', { link = 'TabLine' })
h('TabLineSel', { link = 'StatusLine' })
h('Title', { bold = true })
h('Visual', { fg = bg0, bg = fg0 })
h('VisualNOS', { fg = bg2, bg = fg2 })
h('WarningMsg', { fg = yellow })
h('Whitespace', { link = 'Ignore' })
h('WildMenu', { link = 'CurSearch' })
h('WinBar', { link = 'StatusLine' })
h('WinBarNC', { link = 'StatusLineNC' })

-- Standard syntax highlights
h('Comment', { fg = fg2 })
h('Constant', { link = 'Identifier' })
h('String', { link = 'Character' })
h('Character', { fg = accent0 })
h('Number', { fg = accent0 })
h('Boolean', { link = 'Constant' })
h('Float', { link = 'Number' })
h('Identifier', { fg = fg0 })
h('Function', { link = 'Identifier' })
h('Statement', { link = 'Keyword' })
h('Conditonal', { link = 'Keyword' })
h('Repeat', { link = 'Keyword' })
h('Label', { link = 'Special' })
h('Operator', { fg = fg0 })
h('Keyword', { fg = fg0 })
h('Exception', { link = 'Keyword' })
h('PreProc', { link = 'Special' })
h('Include', { link = 'PreProc' })
h('Define', { link = 'PreProc' })
h('Macro', { link = 'Define' })
h('PreCondit', { link = 'PreProc' })
h('Type', { link = 'Identifier' })
h('StorageClass', { link = 'Keyword' })
h('Structure', { link = 'Keyword' })
h('Typedef', { link = 'Keyword' })
h('Special', { fg = fg0 })
h('SpecialChar', { fg = accent0, bold = true })
h('Tag', { link = 'Identifier' })
h('Delimiter', { link = 'Special' })
h('SpecialComment', { fg = fg2, bold = true })
h('Debug', { link = 'Statement' })
h('Underlined', { underline = true })
h('Ignore', { fg = fg2 })
h('Error', { fg = red })
h('Todo', { link = 'SpecialComment' })
h('Added', { fg = green })
h('Changed', { fg = yellow })
h('Removed', { fg = red })

-- Plugin highlight overrides
h('helpHeader', { link = 'Title' })
h('helpHeadline', { link = 'Title' })
h('helpHyperTextJump', { link = 'Underlined' })
h('helpOption', { link = 'Underlined' })
h('helpURL', { link = 'Underlined' })
h('pdfReference', { link = 'Underlined' })

if vim.g.vimsyn_comment_strings == nil then
  h('vimCommentString', { link = 'Comment' })
end
h('vimCommentTitle', { link = 'SpecialComment' })
h('vimEscape', { link = 'SpecialChar' })
h('vimBracket', { link = 'SpecialChar' })
h('vimNotation', { link = 'SpecialChar' })
h('zigDummyVariable', { link = 'Special' })
h('zigEscape', { link = 'SpecialChar' })
h('zigMultilineStringDelimiter', { link = 'String' })

-- Neovim diagnostic highlights
h('DiagnosticError', { fg = red })
h('DiagnosticWarn', { fg = yellow })
h('DiagnosticInfo', { fg = blue })
h('DiagnosticHint', { fg = accent0 })
h('DiagnosticOk', { fg = green })

h('DiagnosticVirtualTextError', { fg = red, bold = true })
h('DiagnosticVirtualTextWarn', { fg = yellow, bold = true })
h('DiagnosticVirtualTextInfo', { fg = fg0, bold = true })
h('DiagnosticVirtualTextHint', { fg = accent0, bold = true })
h('DiagnosticVirtualTextOk', { fg = green, bold = true })

if vim.g.paragon_quiet_diagnostics then
  h('DiagnosticUnderlineError', { fg = red })
  h('DiagnosticUnderlineWarn', { fg = yellow })
  h('DiagnosticUnderlineInfo', {})
  h('DiagnosticUnderlineHint', {})
  h('DiagnosticUnderlineOk', {})
else
  h('DiagnosticUnderlineError', { undercurl = true, sp = red })
  h('DiagnosticUnderlineWarn', { undercurl = true, sp = yellow })
  h('DiagnosticUnderlineInfo', { undercurl = true, sp = fg0 })
  h('DiagnosticUnderlineHint', { undercurl = true, sp = accent0 })
  h('DiagnosticUnderlineOk', { undercurl = true, sp = green })
end

h('DiagnosticFloatingError', { link = 'DiagnosticError' })
h('DiagnosticFloatingWarn', { link = 'DiagnosticWarn' })
h('DiagnosticFloatingInfo', { link = 'DiagnosticInfo' })
h('DiagnosticFloatingHint', { link = 'DiagnosticHint' })
h('DiagnosticFloatingOk', { link = 'DiagnosticOk' })
h('DiagnosticSignError', { link = 'DiagnosticError' })
h('DiagnosticSignWarn', { link = 'DiagnosticWarn' })
h('DiagnosticSignInfo', { link = 'DiagnosticInfo' })
h('DiagnosticSignHint', { link = 'DiagnosticHint' })
h('DiagnosticSignOk', { link = 'DiagnosticOk' })

h('DiagnosticDeprecated', { strikethrough = true, sp = fg2 })

if vim.g.paragon_quiet_diagnostics then
  h('DiagnosticUnnecessary', { bg = bg2 })
else
  h('DiagnosticUnnecessary', { undercurl = true, sp = fg2 })
end

-- Neovim tree-sitter highlights
h('@variable', { link = 'Identifier' })
h('@variable.builtin', { link = 'Special' })
h('@variable.parameter', { link = '@variable' })
h('@variable.parameter.builtin', { link = '@variable.builtin' })
h('@variable.member', { link = '@variable' })
h('@constant', { link = 'Constant' })
h('@constant.builtin', { link = 'Special' })
h('@constant.macro', { link = '@constant' })
h('@module', { link = 'Identifier' })
h('@module.builtin', { link = 'Special' })
h('@label', { link = 'Label' })
h('@string', { link = 'String' })
h('@string.documentation', { link = 'Comment' })
h('@string.regexp', { link = '@string' })
h('@string.escape', { link = 'SpecialChar' })
h('@string.special', { link = '@string' })
h('@string.special.symbol', { link = '@string' })
h('@string.special.path', { link = '@string' })
h('@string.special.url', { link = 'Underlined' })
h('@character', { link = 'Character' })
h('@character.special', { link = '@character' })
h('@boolean', { link = 'Boolean' })
h('@number', { link = 'Number' })
h('@number.float', { link = 'Float' })
h('@type', { link = 'Type' })
h('@type.builtin', { link = 'Special' })
h('@type.definition', { link = 'Type' })
h('@attribute', { link = 'Macro' })
h('@attribute.builtin', { link = 'Special' })
h('@property', { link = 'Identifier' })
h('@function', { link = 'Function' })
h('@function.builtin', { link = 'Special' })
h('@function.call', { link = '@function' })
h('@function.macro', { link = '@function' })
h('@function.method', { link = '@function' })
h('@function.method.call', { link = '@function' })
h('@constructor', { link = 'Identifier' })
h('@operator', { link = 'Operator' })
h('@keyword', { link = 'Keyword' })
h('@keyword.coroutine', { link = '@keyword' })
h('@keyword.function', { link = '@keyword' })
h('@keyword.operator', { link = '@keyword' })
h('@keyword.import', { link = '@keyword' })
h('@keyword.type', { link = '@keyword' })
h('@keyword.modifier', { link = '@keyword' })
h('@keyword.repeat', { link = '@keyword' })
h('@keyword.return', { link = '@keyword' })
h('@keyword.debug', { link = '@keyword' })
h('@keyword.exception', { link = '@keyword' })
h('@keyword.conditional', { link = '@keyword' })
h('@keyword.conditional.ternary', { link = '@operator' })
h('@keyword.directive', { link = '@keyword' })
h('@keyword.directive.define', { link = '@keyword' })
h('@punctuation', { link = 'Delimiter' })
h('@punctuation.delimiter', { link = '@punctuation' })
h('@punctuation.bracket', { link = '@punctuation' })
h('@punctuation.special', { link = '@punctuation' })
h('@comment', { link = 'Comment' })
h('@comment.documentation', { link = '@comment' })
h('@comment.error', { fg = red, bold = true })
h('@comment.warning', { fg = yellow, bold = true })
h('@comment.todo', { link = 'SpecialComment' })
h('@comment.note', { link = 'SpecialComment' })
h('@markup', { link = 'Comment' })
h('@markup.strong', { bold = true })
h('@markup.italic', { italic = true })
h('@markup.strikethrough', { strikethrough = true })
h('@markup.underline', { link = 'Underlined' })
h('@markup.heading', { link = 'Title' })
h('@markup.heading.1', { link = '@markup.heading' })
h('@markup.heading.2', { link = '@markup.heading' })
h('@markup.heading.3', { link = '@markup.heading' })
h('@markup.heading.4', { link = '@markup.heading' })
h('@markup.heading.5', { link = '@markup.heading' })
h('@markup.heading.6', { link = '@markup.heading' })
h('@markup.quote', {})
h('@markup.math', { link = 'String' })
h('@markup.link', { link = 'Underlined' })
h('@markup.link.label', { link = '@markup.link' })
h('@markup.link.url', { link = '@markup.link' })
h('@markup.raw', {})
h('@markup.raw.block', { link = '@markup.raw' })
h('@markup.list', {})
h('@markup.list.checked', { fg = green })
h('@markup.list.unchecked', { link = '@markup.list' })
h('@diff.plus', { link = 'Added' })
h('@diff.minus', { link = 'Removed' })
h('@diff.delta', { link = 'Changed' })
h('@tag', { link = 'Identifier' })
h('@tag.builtin', { link = 'Special' })
h('@tag.attribute', { link = '@tag' })
h('@tag.delimiter', { link = 'Delimiter' })
h('@constant.comment', { link = 'SpecialComment' })
h('@number.comment', { link = 'Comment' })
h('@punctuation.bracket.comment', { link = 'SpecialComment' })
h('@punctuation.delimiter.comment', { link = 'SpecialComment' })
h('@label.vimdoc', { link = 'String' })
h('@markup.heading.1.delimiter.vimdoc', { link = '@markup.heading.1' })
h('@markup.heading.2.delimiter.vimdoc', { link = '@markup.heading.2' })

-- Neovim LSP semantic highlights
h('@lsp.type.class', { link = '@type' })
h('@lsp.type.comment', { link = '@comment' })
h('@lsp.type.decorator', { link = '@attribute' })
h('@lsp.type.enum', { link = '@type' })
h('@lsp.type.enumMember', { link = '@constant' })
h('@lsp.type.event', { link = '@type' })
h('@lsp.type.function', { link = '@function' })
h('@lsp.type.interface', { link = '@type' })
h('@lsp.type.keyword', { link = '@keyword' })
h('@lsp.type.macro', { link = 'Macro' })
h('@lsp.type.method', { link = '@function.method' })
h('@lsp.type.modifier', { link = '@type.qualifier' })
h('@lsp.type.namespace', { link = '@module' })
h('@lsp.type.number', { link = '@number' })
h('@lsp.type.operator', { link = '@operator' })
h('@lsp.type.parameter', { link = '@variable.parameter' })
h('@lsp.type.property', { link = '@property' })
h('@lsp.type.regexp', { link = '@string.regexp' })
h('@lsp.type.string', { link = '@string' })
h('@lsp.type.struct', { link = '@type' })
h('@lsp.type.type', { link = '@type' })
h('@lsp.type.typeParameter', { link = '@type.definition' })
h('@lsp.type.variable', { link = '@variable' })

h('@lsp.mod.abstract', {})
h('@lsp.mod.async', {})
h('@lsp.mod.declaration', {})
h('@lsp.mod.defaultLibrary', {})
h('@lsp.mod.definition', {})
h('@lsp.mod.deprecated', { link = 'DiagnosticDeprecated' })
h('@lsp.mod.documentation', {})
h('@lsp.mod.modification', {})
h('@lsp.mod.readonly', {})
h('@lsp.mod.static', {})

-- Neovim LSP other highlights
h('LspReferenceText', { bg = bg2 })
h('LspReferenceRead', { link = 'LspReferenceText' })
h('LspReferenceWrite', { link = 'LspReferenceText' })
h('LspReferenceTarget', { link = 'LspReferenceText' })
h('LspInlayHint', { link = 'NonText' })
h('LspCodeLens', { link = 'NonText' })
h('LspCodeLensSeparator', { link = 'NonText' })
h('LspSignatureActiveParameter', { link = 'LspReferenceText' })
h('IndentLineCurrent', { link = 'Comment' })
