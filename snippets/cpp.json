{
  "beginend": {
    "prefix": "beginend",
    "body": "${1:container}.begin(), ${1:container}.end()",
    "description": "Snippet for begin/end iterator pair"
  },
  "for_i": {
    "prefix": "fori",
    "body": [
      "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {",
      "\t$0",
      "}"
    ],
    "description": "Integer for loop"
  },
  "for_range": {
    "prefix": "for",
    "body": [
      "for (const auto& ${1:item} : ${2:container}) {",
      "\t$0",
      "}"
    ],
    "description": "Range-based for loop (const ref)"
  },
  "for_range_mut": {
    "prefix": "form",
    "body": [
      "for (auto& ${1:item} : ${2:container}) {",
      "\t$0",
      "}"
    ],
    "description": "Range-based for loop (mutable)"
  },
  "for_iter": {
    "prefix": "forit",
    "body": [
      "for (auto ${1:it} = ${2:vec}.begin(); ${1:it} != ${2:vec}.end(); ++${1:it}) {",
      "\t$0",
      "}"
    ],
    "description": "Iterator for loop"
  },
  "while": {
    "prefix": "while",
    "body": [
      "while (${1:condition}) {",
      "\t$0",
      "}"
    ],
    "description": "While loop"
  },
  "do_while": {
    "prefix": "do",
    "body": [
      "do {",
      "\t$0",
      "} while (${1:condition});"
    ],
    "description": "Do-while loop"
  },
  "if": {
    "prefix": "if",
    "body": [
      "if (${1:condition}) {",
      "\t$0",
      "}"
    ],
    "description": "If statement"
  },
  "if_else": {
    "prefix": "ife",
    "body": [
      "if (${1:condition}) {",
      "\t$2",
      "} else {",
      "\t$0",
      "}"
    ],
    "description": "If-else statement"
  },
  "elif": {
    "prefix": "elif",
    "body": [
      "else if (${1:condition}) {",
      "\t$0",
      "}"
    ],
    "description": "Else-if statement"
  },
  "switch": {
    "prefix": "switch",
    "body": [
      "switch (${1:expr}) {",
      "\tcase ${2:value}:",
      "\t\t$0",
      "\t\tbreak;",
      "\tdefault:",
      "\t\tbreak;",
      "}"
    ],
    "description": "Switch statement"
  },
  "class": {
    "prefix": "class",
    "body": [
      "class ${1:ClassName} {",
      "private:",
      "\t$0",
      "",
      "public:",
      "\t${1:ClassName}() = default;",
      "\t~${1:ClassName}() = default;",
      "};"
    ],
    "description": "Class definition"
  },
  "struct": {
    "prefix": "struct",
    "body": [
      "struct ${1:Name} {",
      "\t$0",
      "};"
    ],
    "description": "Struct definition"
  },
  "enum_class": {
    "prefix": "enum",
    "body": [
      "enum class ${1:Name} {",
      "\t$0",
      "};"
    ],
    "description": "Enum class (scoped)"
  },
  "namespace": {
    "prefix": "ns",
    "body": [
      "namespace ${1:name} {",
      "",
      "$0",
      "",
      "}  // namespace ${1:name}"
    ],
    "description": "Namespace"
  },
  "function": {
    "prefix": "fn",
    "body": [
      "${1:void} ${2:name}(${3:}) {",
      "\t$0",
      "}"
    ],
    "description": "Function definition"
  },
  "main": {
    "prefix": "main",
    "body": [
      "int main() {",
      "\t$0",
      "\treturn 0;",
      "}"
    ],
    "description": "Main function"
  },
  "lambda": {
    "prefix": "lam",
    "body": "[${1:}](${2:}) { $0 }",
    "description": "Lambda expression"
  },
  "template": {
    "prefix": "temp",
    "body": [
      "template <typename ${1:T}>",
      "$0"
    ],
    "description": "Template"
  },
  "template_class": {
    "prefix": "tempc",
    "body": [
      "template <typename ${1:T}>",
      "class ${2:Name} {",
      "public:",
      "\t$0",
      "};"
    ],
    "description": "Template class"
  },
  "unique_ptr": {
    "prefix": "uptr",
    "body": "auto ${1:ptr} = std::make_unique<${2:Type}>(${3:});$0",
    "description": "Unique pointer"
  },
  "shared_ptr": {
    "prefix": "sptr",
    "body": "auto ${1:ptr} = std::make_shared<${2:Type}>(${3:});$0",
    "description": "Shared pointer"
  },
  "vector": {
    "prefix": "vec",
    "body": "std::vector<${1:int}> ${2:v}${3:;}$0",
    "description": "Vector declaration"
  },
  "map": {
    "prefix": "map",
    "body": "std::map<${1:KeyType}, ${2:ValueType}> ${3:m}${4:;}$0",
    "description": "Map declaration"
  },
  "unordered_map": {
    "prefix": "umap",
    "body": "std::unordered_map<${1:KeyType}, ${2:ValueType}> ${3:m}${4:;}$0",
    "description": "Unordered map declaration"
  },
  "set": {
    "prefix": "set",
    "body": "std::set<${1:Type}> ${2:s}${3:;}$0",
    "description": "Set declaration"
  },
  "sort": {
    "prefix": "sort",
    "body": "std::sort(${1:vec}.begin(), ${1:vec}.end());$0",
    "description": "Sort container"
  },
  "find": {
    "prefix": "find",
    "body": "auto ${1:it} = std::find(${2:vec}.begin(), ${2:vec}.end(), ${3:val});$0",
    "description": "Find in container"
  },
  "find_if": {
    "prefix": "findif",
    "body": [
      "auto ${1:it} = std::find_if(${2:vec}.begin(), ${2:vec}.end(),",
      "\t[](const auto& ${3:x}) { return ${0:condition}; });"
    ],
    "description": "Find if in container"
  },
  "transform": {
    "prefix": "transform",
    "body": [
      "std::transform(${1:in}.begin(), ${1:in}.end(), ${2:out}.begin(),",
      "\t[](const auto& ${3:x}) { return ${0:expr}; });"
    ],
    "description": "Transform algorithm"
  },
  "include": {
    "prefix": "#inc",
    "body": "#include <${1:iostream}>",
    "description": "Include header"
  },
  "include_local": {
    "prefix": "#incl",
    "body": "#include \"${1:header.h}\"",
    "description": "Include local header"
  },
  "pragma_once": {
    "prefix": "#pragma",
    "body": "#pragma once",
    "description": "Pragma once"
  },
  "ifndef": {
    "prefix": "#guard",
    "body": [
      "#ifndef ${1:HEADER}_H",
      "#define ${1:HEADER}_H",
      "",
      "$0",
      "",
      "#endif  // ${1:HEADER}_H"
    ],
    "description": "Header guard"
  },
  "cout": {
    "prefix": "cout",
    "body": "std::cout << ${1:} << '\\n';$0",
    "description": "Console output"
  },
  "cerr": {
    "prefix": "cerr",
    "body": "std::cerr << ${1:} << '\\n';$0",
    "description": "Error output"
  },
  "cin": {
    "prefix": "cin",
    "body": "std::cin >> ${1:var};$0",
    "description": "Console input"
  },
  "try_catch": {
    "prefix": "try",
    "body": [
      "try {",
      "\t$0",
      "} catch (const std::exception& ${1:e}) {",
      "\t${2:// handle}",
      "}"
    ],
    "description": "Try-catch block"
  },
  "auto": {
    "prefix": "auto",
    "body": "auto ${1:var} = ${2:value};$0",
    "description": "Auto variable"
  },
  "constexpr": {
    "prefix": "constexpr",
    "body": "constexpr ${1:auto} ${2:var} = ${3:value};$0",
    "description": "Constexpr variable"
  },
  "nullptr": {
    "prefix": "nullptr",
    "body": "nullptr",
    "description": "Null pointer"
  },
  "static_cast": {
    "prefix": "scast",
    "body": "static_cast<${1:Type}>(${2:expr})$0",
    "description": "Static cast"
  },
  "dynamic_cast": {
    "prefix": "dcast",
    "body": "dynamic_cast<${1:Type}>(${2:expr})$0",
    "description": "Dynamic cast"
  },
  "structured_binding": {
    "prefix": "auto[]",
    "body": "auto [${1:a}, ${2:b}] = ${3:pair};$0",
    "description": "Structured binding"
  }
}
